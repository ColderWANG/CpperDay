- [thread多线程基础](#thread多线程基础)
  - [1.线程传递参数详解](#1线程传递参数详解)
  - [2.传递类对象、智能指针作为线程参数](#2传递类对象智能指针作为线程参数)
    - [2.1std::ref() 函数](#21stdref-函数)
  - [3.成员函数作为线程函数](#3成员函数作为线程函数)
  - [4.创建等待多个线程](#4创建等待多个线程)

----------------------------------------------
## thread多线程基础
### 1.线程传递参数详解
thread 以引用形式传递的参数为**假引用传递**，实际是值传递，而指针传递为真，在用 detach 的时候最好别用引用传递，更不能用指针传递。
> 注：thread 的构造函数决定了无论传递什么参数，都是复制的一个临时量，**对于临时量要const引用**，加了const可以接受右值

参数存在例如 char[] 到 string 的隐式转化时，用了 detach 后，无法预测隐式转化什么时候成功，若主线程结束而还没转化时，就会报错。解决方法就是临时构造一个A类对象作为参数传入线程。

总结：
1. 若用 detach 则在传递 int 这种简单参数，建议用值传递 
2. 如果传递类对象，避免隐式类型转化。全部都在创建线程这一行就构建出临时对象，然后再函数参数里用引用来接，否则会多构造一次对象，造成三次构造。


### 2.传递类对象、智能指针作为线程参数      
#### 2.1std::ref() 函数     
由于 thread 类的特殊性，无论是传递引用参数还是值参数，线程内部都会对其进行一个**拷贝**，若要把类对象以**真引用传递**进去，需要用 std::ref() 函数，同时线程函数的参数里**不需要添加const**，也不需要在类里创造 mutable 变量。
 
### 3.成员函数作为线程函数      
写法：
```cpp
std::thread FuncName(&ClassName::memberFunc, ClassObjName, para);
//上述代码对类对象进行拷贝构造
std::thread FuncName(&ClassName::memberFunc, &ClassObjName, para);
//这里&传入this指针，可以等价于 std::ref()函数,在子线程中不会对类对象拷贝构造

/***仿函数作为线程函数***/
std::thread FuncName(std::ref(ClassObjName),para);
//这里&传入对象，会报错，只能使用std::ref(ClassObjName)
```

### 4.创建等待多个线程
用容器来创建多个线程，如 vector<thread> ,多个线程执行顺序是乱的。