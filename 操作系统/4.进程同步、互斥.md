- [1 进程同步](#1-进程同步)
- [2 进程互斥](#2-进程互斥)
- [3 进程互斥的软件实现方法](#3-进程互斥的软件实现方法)
  - [3.1 单标志法](#31-单标志法)
  - [3.2 双标志先检查法](#32-双标志先检查法)
  - [3.3 双标志后检查法](#33-双标志后检查法)
  - [3.4 Peterson 算法](#34-peterson-算法)
- [4 进程互斥的硬件实现方法](#4-进程互斥的硬件实现方法)
  - [4.1 中断屏蔽方法](#41-中断屏蔽方法)
  - [4.2 TestAndSet指令](#42-testandset指令)
  - [4.3 Swap 指令 或Exchange 指令（XCHG指令）](#43-swap-指令-或exchange-指令xchg指令)

# 1 进程同步
因为进程并发执行的异步性，程序以不可预知的顺序执行，**同步**也就是直接制约关系，**协调**他们的**工作次序**

# 2 进程互斥
两种资源共享方式
1. 互斥共享 一个时间段只允许一个进程访问资源
2. 同时共享 一个时间段运行多个进程“**同时**”访问资源

**临界资源**就是一个时间段只允许一个进程使用的资源，必须**互斥**访问

有**四个区** 进入区、临界区、退出区、剩余区
有**四条原则** 空闲让进、忙则等待、有限等待、让权等待

# 3 进程互斥的软件实现方法
## 3.1 单标志法
进程进入临界区的权限只能被另一个进程赋予

缺点：违背空闲让进原则（临界区空闲，则让另一个进程访问），进程1上锁后，进入临界区前处理数据的时候，临界区处于空闲，而进程2不能进入。
## 3.2 双标志先检查法
用数组标记各进程进入临界区的意愿

缺点：违反忙则等待原则（临界区忙碌，则让另一个进程等待），因为进入区的检查和上锁**不是一气呵成**的，检查后，上锁前可能发生进程切换。

## 3.3 双标志后检查法
先上锁后检查

缺点：违背了空闲让进和有限等待的原则，由于检查和上锁不是一气呵成的，有会陷入死循环，产生**饥饿**现象。

## 3.4 Peterson 算法
用数组标记各进程进入临界区的意愿，同时创建单标志，表示可以让给标志进程先进入。即双方都想进入临界区时，可以让进程尝试“孔融让梨”

优点：遵循了空闲让进、忙则等待、有限等待
缺点：未遵循让权等待（进程不能进入临界区时，应立即释放处理机，防止进程忙等待）

# 4 进程互斥的硬件实现方法

## 4.1 中断屏蔽方法
利用开/关中断实现,关中断后不允许当前进程被切换

优点：简单高效
缺点：**不适用于多处理机系统**； **只适用于操作系统内核进程**，不适用用户进程（开/关中断只能运行在内核态，用户随意使用很危险）

## 4.2 TestAndSet指令
TSL指令是用硬件实现的，检查一个lock是否被上锁，**实现TSL逻辑**为：对lock上锁，并返回原来的值。

**实现互斥的逻辑**为
```cpp
while(TestAndSet(&lock));  //若原来没上锁，会退出循环并上锁；若原来上锁，会循环等待。
临界区代码...
lock = false //解锁
剩余区代码...
```

优点：实现简单，无需检查漏洞，并且适用于多处理机环境
缺点：未遵循让权等待原则（暂时无法进入临界区的进程会占用CPU并循环执行TSL指令，从而导致忙等）

## 4.3 Swap 指令 或Exchange 指令（XCHG指令）
和 TSL 指令逻辑上一样，硬件层次实现不一样，所以优缺点一样。