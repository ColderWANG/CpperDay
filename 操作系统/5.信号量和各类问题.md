- [1 信号量机制](#1-信号量机制)
  - [1.1 整型信号量](#11-整型信号量)
  - [1.2 记录型信号量](#12-记录型信号量)
- [2 信号量机制实现进程互斥、同步、前驱](#2-信号量机制实现进程互斥同步前驱)
  - [2.1 实现互斥（先P后V）](#21-实现互斥先p后v)
  - [2.2 实现同步（先V后P）](#22-实现同步先v后p)
  - [2.3 信号量实现前驱关系](#23-信号量实现前驱关系)
- [3 生产者-消费者问题](#3-生产者-消费者问题)
- [4 多生产者-多消费者问题](#4-多生产者-多消费者问题)
- [5 抽烟者问题](#5-抽烟者问题)
- [6 读者-写者问题](#6-读者-写者问题)
- [7 哲学家问题](#7-哲学家问题)
- [8 管程](#8-管程)

# 1 信号量机制
是一种实现进程同步、互斥的方法。由**一对原语**对**信号量**进行操作，可以实现互斥、同步。

信号量是一个变量，表示系统中某种重要的资源的数量。

一对原语 wait（P 操作） 和 signal（V 操作）

## 1.1 整型信号量
与普通整数变量的区别：
对信号量的操作只有三种即 初始化、P操作、V操作
1. 初始化         -- 设置**资源数**
2. 在进入区 wait（P操作）  -- while循环检查锁，上锁 **资源数-1**
3. 在退出区 signal（V操作）-- **资源数+1**

优点： 检查上锁一气呵成 ，避免并发、异步导致的问题
缺点：不满足让权等待

## 1.2 记录型信号量
记录型信号量结构、wait、signal 为：
```cpp
typedef struct{
    int value;         //剩余资源数
    struct process *L  //等待队列
}semaphore;
//某进程需要使用资源时，通过 wait 原语申请
void wait(semaphore S){
    S.value--;
    //如果剩余资源数不够，使用 block 原语使进程从 运行态-->阻塞态，并挂到信号量S的等待队列（阻塞队列）中
    if(S.value < 0)block(S.L)
}
//进程使用完资源后，通过 signal 原语释放
void signal(semaphore S){
    s.value++;
    //资源释放，剩余资源数+1，如果资源数小于等于0，说明队列还有进程在等待，唤醒阻塞队头进程
    if(S.value <= 0)wakeup(S.L); 
}

```
优点：**满足了让权等待**

# 2 信号量机制实现进程互斥、同步、前驱
## 2.1 实现互斥（先P后V）

1. 划定临界区
2. 设置**互斥信号量 mutex**，初值为1
3. 在临界区之前执行P(mutex)
4. 在临界区之后执行V(mutex)
   
> 注意：对不同的临界资源需要**设置不同互斥量** mutex1 mutex2，且必须成对出现

## 2.2 实现同步（先V后P）

1. 分析什么时候需要保证“一前一后”执行两个操作（不同进程的两个操作）
2. 设置**同步信号量 S**，初始为0
3. 在前操作之后执行V(S)      // S++ S变为1，说明有可用资源
4. 在后操作之前执行P(S)

## 2.3 信号量实现前驱关系
是一种多层的同步关系
1. 对每一对前驱关系各设置一个同步变量
2. 在前操作之后对**相应的同步变量**执行V(S)
3. 在后操作之前对**相应的同步变量**执行P(S)

# 3 生产者-消费者问题
生产者、消费者共同维护一个**初始为空、大小为 n 的缓冲区**（同步）

只有**缓冲区没满**时，生产者才能把产品放入缓冲区，否则必须等待（同步）

只有**缓冲区不空**时，消费者才能从中取出产品，否则必须等待（同步）

缓冲区是临界资源，对各进程必须**互斥访问**（互斥）

流程思路：
定义 缓冲区同步信号量（初始资源为n）、产品同步信号量（初始资源为0）、一个缓冲区互斥信号量（初始资源为1）
生产者进程：每次生产要消耗一个空闲缓冲区（**P操作对应缓冲区同步信号量**），生产一个产品（**V操作对应产品同步信号量**）
消费者进程：每次要消耗一个产品（**P操作对应产品同步信号量**），并释放一个空闲缓冲区（**V操作对应缓冲区同步信号量**）
互斥：在缓冲区放入、取出要互斥，但是**P操作实现互斥要在实现同步之后，而V操作不会导致死锁，可以互换**

# 4 多生产者-多消费者问题
多类产品，如果只有一个缓冲区，**只有一个缓冲区的情况，互斥量可以不用设置**，在缓冲区大小大于1的时候，需要设置互斥量。**从事件出发分析需要几个同步信号量**

# 5 抽烟者问题
假设有**三个抽烟者进程**和**一个供应者进程**，抽烟需要三种材料，三个抽烟者各自拥有一个，需要另外两个，在这个问题中，供应者会无限供应两种材料（**一种组合也就是一个缓冲区**），一个抽烟者取走后提示供应者已经取走，此时下一个抽烟者去拿。

流程思路：
定义 组合1 组合2 组合3 同步信号量初始为0，抽烟完成同步信号量初始为0

供应者进程：轮流提供材料
抽烟者进程：先V后P（同步）

# 6 读者-写者问题
有一个**共享文件**，读文件不会改变数据，可以同时访问；写进程和其他任意进程不能同时访问。
所以有4点要求：
1. 允许多个读者同时读文件
2. 只允许一个写者写文件
3. 任一写者写之前让其他所有人退出
4. 写者写完之前不允许其他所有人工作

流程思路：
定义 文件访问互斥量rw = 1，**读进程正在读文件计数 count**，**对count的互斥访问量 mutex**。**用于实现写优先或读写公平法的互斥量 w**。
写进程：在写之前P，写之后V
读进程：在count == 0 时 P，同时count+1，读完后 count-1，如果count == 0 则V操作，此时如果对count 的检查和赋值无法一气呵成，则会**在P操作阻塞**，此时需要通过mutex，在count检查和赋值上下先P后V

潜在问题：读者优先，如果读者源源不断来读，写者可能**饿死**

```
writer(){
    while(1){
        P(w);      //读写公平或称写优先 互斥量上锁
        P(rw);     //读写互斥 、写写互斥
        写文件...
        V(rw)；
        V（w）
    }
}
reader(){
    while(1){
        P(w);                 //读写公平互斥
        P(mutex);             //读进程之间保证count检查和赋值不可被中断
        if(count == 0)P(rw);  //读写互斥
        count++;
        V(mutex);
        V(w);
        读进程...
        P(mutex);
        count--;
        if(count == 0)V(rw);
        V(mutex);
    }
}
```

# 7 哲学家问题
一张圆桌上有5个哲学家，有5根筷子，**只有互斥问题**，如果5个哲学家都拿起了左手的筷子，会**进入死锁**
解决方案：3选1即可
1. 最多允许4个哲学家同时进餐，这保证了至少有一个可以拿到两个筷子
2. 要求奇数号哲学家先拿左边，偶数号哲学家先拿右边
3. 各哲学家**拿筷子这件事互斥地执行**。

# 8 管程
 管程是一种特殊的软件模块，有这些部分组成
 1. 局部于管程的**共享数据结构**石观音
 2. 对该数据结构进行操作的**一组过程**（函数）
 3. 对共享数据设置初始值的语句
 4. 管程有一个名字

特征：
1. 局部于管程的数据只能被其中的过程访问
2. 一个进程只有调用管程内的过程才能进入管程访问共享数据
3. **每次仅允许一个进程在管程内执行某个过程**