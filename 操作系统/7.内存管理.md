# 1 内存
编写、编译、链接、装入
## 1.1 装入的三种方式
装入实现逻辑地址到物理地址的转换，有3种方式
1. 绝对转入     --在编译时，已经知道程序的绝对地址，则编译程序产生绝对地址的代码
2. 静态重定位   --在装入时，对地址进行**重定位**，如加减
3. 动态重定位   --编译、链接后的装入模块的地址都是从0开始，装入程序装入内存后，并不会立即把逻辑地址转化为物理底子好，而是**把地址转换推迟到程序真正执行的时候**，装入内存后所有的地址依然是逻辑地址，这种方式需要一个**重定位寄存器**。

## 1.2 链接的三种方式
1. 静态链接
2. 装入时动态链接
3. 运行时动态链接

# 2 内存管理概念
实现的功能：
1. 操作系统负责**内存空间的分配与回收**
2. 从逻辑上对**内存空间进行扩充**
3. 提供地址转换功能，负责程序的**逻辑地址**与**物理地址**的转换
4. 提**供内存保护**的功能
## 2.1 内存保护
内存保护可以采用两种方法
1. 设置上下限寄存器。
2. 采用重定位寄存器（基址寄存器）和界地址寄存器（限长寄存器）进行越界检查，重定位寄存器存放进程的**起始物理地址**，界地址寄存器存放进程的**最大逻辑地址**

# 3 内存空间的分配与回收
## 3.1 覆盖技术
解决“程序大小超过物理内存综合”的问题

思想：把**程序分为多个段**，设立一个**固定区**，和若干个**覆盖区**，让不能被同时被访问的程序段共享同一个覆盖区

缺点：对用户不透明，必须由程序员声名覆盖结构，增加用户编程负担

## 3.2 交换技术
内存紧张时，系统将内存中某些进程暂时**换出**内存，把外存中某些已具备运行条件的进程**换入**内存，暂时挂起的进程为挂起状态。

1. 磁盘存储空间分为**文件区**和**对换区**，**文件区**主要用于存放文件，主要追求存储空间的利用率，采用**离散分配方式**。**对换区**占用空间小，被换出的进程数据就存放在对换区。对换区主要追求换入换出速度，采用**连续分配方式**，对换区的I/O速度比文件区更快
2. 什么时候应该交换？许多进程运行且内存吃紧时进行，如许多进程运行时经常发生缺页
3. 应该换出哪些进程？可优先换出阻塞进程，可换出优先级低的进程

# 4 连续分配管理方式
## 4.1 单一连续分配
内存被分为**系统区**和**用户区**，内存**只有一道用户程序**
优点：实现简单，无外部碎片，可以采用覆盖技术扩充内存
缺点：只能用于单用户、单任务，有内部碎片，存储区利用率极低

## 4.2 固定分区分配
整个**用户空间**分为**若干个固定大小分区**，每个分区只装入一道作业
1. 分区大小相等 缺乏灵活性
2. 分区大小不等 增加灵活性
操作系统建立一个数据结构--**分区说明表**，表项包括大小、起始地址、状态（是否已分配）
优点：**无外部碎片**
缺点：程序太大，分区都不满足，会**产生内部碎片**

## 4.3 动态分区分配
又称可变分区分配，**不会预先划分内存分区**，而是在进程装入内存时，**根据进程的大小动态地建立分区**，动态分区没有内部碎片，但是有外部碎片。可以通过**紧凑**技术来解决外部碎片
### 4.3.1 要用什么数据结构记录内存使用情况
1. **空闲分区表** 分区号、分区大小、分区起始地址、状态
2. **空闲分区链** 一个链表把分区连接起来，**起始部分设置前驱指针**，**末尾部分设置后向指针**，起始部分可记录分区大小等信息

### 4.3.2 选择哪个分区进行分配
动态分区分配算法

### 4.3.3 如何进行分区的分配和回收
回收后有空闲分区相邻，则要合并

# 5 动态分区分配算法
## 5.1 首次适应算法
思想：每次从**低地址开始查找**，找到第一个满足大小的空闲分区
如何实现：**空闲分区以地址递增的次序排列**，每次分配内存时顺序查找空闲分区链（或空闲分区表），
## 5.2 最佳适用算法
思想：优先使用更小的空闲区
如何实现：**空闲分区按容量递增次序链接**，按顺序查找空闲分区链或表
缺点：产生很多外部碎片

## 5.3 最坏适应算法
思想：优先使用最大的连续空闲区
如何实现：**空闲分区按容量递减次序链接**，按顺序查找空闲分区链
缺点：大容量分区会先被消耗，导致后来的大进程无法运行

## 5.3 邻近适应算法
思想：从上次查找结束的位置开始检索
如何实现：**空闲分区按地址递增顺序排列（可排成一个循环链表）**，每次分配内存时从**上次查找结束的位置**开始查找空闲分区链或表。

# 6 基本分页存储管理的基本概念（非连续分配管理方式）
把内存分为一个个相等的小分区，在按照分区大小把**进程拆分**为一个个小部分。可以看作时固定分区分配的**非连续版本**

内存小分区就是一个**页框（页帧、内存块、物理块）**，每个页框有**页框号**从0开始。

用户进程的地址空间分为**和页框大小相等**的一个个区域，也称为**页（页面）**，对应的**页号**从0开始。

## 6.1 如何实现地址转换
### 6.1.1 第一种计算方式（人工）
1. 计算逻辑地址对应的**页号**                      逻辑地址 / 页面长度
2. 要知道**该页号**对应**页面在内存中的起始地址**   操作系统记录
3. 要算出**逻辑地址在页面内的偏移量**               逻辑地址 % 页面长度
4. 物理地址 = 页面起始地址 + 页内偏移量

### 6.1.2 第二种计算方式（计算机）
页面大小一般为**2的整数幂**
1. 计算**页号**               （位运算）页面大小为2^12B = 4KB时，第13位开始表示页号
2. 要知道**该页号**对应**页面在内存中的起始地址**   操作系统记录
3. 页内偏移量                  （位运算）前12位表示业内偏移
4. 物理地址位 = 页面起始地址+偏移量

### 6.1.3 页表
操作系统为每个进程建立一张页表
1. 一个进程对应一张页表
2. 进程的每一页对应一个页表项
3. 每个页表项由**页号**和**内存块号或页框号**组成，内存块的数量是物理内存大小/页面大小，
4. 页表记录**进程页面和实际存放的内存块之间的对应关系**

## 6.2 基本地址变换机构（实现逻辑地址到物理地址转换的一组硬件机构）
系统中设置一个**页表寄存器**（PTR），存放页表在内存中的起始地址F和页表长度M，进程未执行时，页表始址和页表长度放在**进程控制块PCB**中，当进程被调度时，会放到PTR中。
> 页面大小是2的整数幂

## 6.3 具有快表的地址变换机构
### 6.3.1 快表
快表，又称**联想寄存器TLB**，是一种**访问速度比内存快很多**的高速缓冲存储器，用来存放当前访问的若干页表项，来加速地址变换，于此对应，内存中的页表常称为**慢表**

## 6.4 两级页表
这里整理一下各个专业术语
1. 页表大小（长度？） = 页表项数量 * 页表项长度（设为4B，位数和系统的位数相同，可以避免产生碎片）
2. 页框大小（物理内存块的大小） = 页面大小（用户进程地址空间的一个区域） = 页内地址数（逻辑地址划分成前面的页号和后面的页内偏移地址）
3. **页表是存储在页框中的**，页框的数量 = 页表大小（长度？）/ 页框大小（页面大小）

根据页号在页表查询页表项的方法：K号页对应的页表项存放位置 = 页表起始地址 + K*页表项长度（4B），所有的页表项都**连续存放**的基础上才能用这种方法找到页表项。

单级页表存在的问题：
1. **页表必须连续存放，当页表很大时，需要占用多个连续的页框**
2. 没必要让整个页表常驻内存，因为进程在一段实际内可能只需要访问某几个特定的页面

问题1的解决：再建立一张页表，称为**页目录表**，或称**外层页表**、**顶层页表**，类似于套娃
问题2的解决：在需要访问页面时，才把页面调入内存（虚拟存储技术），在页表项中加入一个标志位，表示该页面是否以及调入内存

# 7.基本分段存储管理（非连续）
## 7.1 分段
按照程序自身的逻辑划分位若干个段，每个段在内存中**占据连续空间**，但**各个段可以不相邻**

## 7.2 段表
1. 和页表类似，每个段对应一个段表项，记录该段在内存的**起始位置**，和**段的长度**
2. **各个段表项的长度是相同**（其实很容易理解）最大段长是一个常量例如16位，物理内存大小4GB，也就是32位，则每个段表项是48位，即6B。由于段表项的长度相等，**段号可以隐藏，不占存储空间**

## 7.3 分段、分页管理对比
页是**信息的物理单位**，对用户是不可见的，是系统行为，地址空间是1维的，只需要给出内存块号。段是**信息的逻辑单位**，对用户是可见的，需要用户编程时显式给出段名，地址空间是二维的，既要给出段名，又要给出段内地址。

分段比分页更容易实现信息的共享和保护

# 8. 段页式管理方式（非连续）
分页管理：
> 优点：内存空间利用率高，**不会产生外部碎片**
> 缺点：不方便按照逻辑模块实现信息的共享和保护

分段管理：
> 优点：容易实现信息的共享和保护
> 缺点：如果段长过大，为其分配很大的连续空间会很不方便，还**会产生外部碎片**

把进程地址空间分为段，每个段再分为页

# 9. 虚拟内存
传统存储管理（连续分配与非连续分配）的特征和缺点
1. 一次性：作业必须一次性装入内存后才开始运行，会造成两个问题（1）作业很大时不能装入，无法运行。（2）大量作业要求运行时，多道程序并发度下降。
2. 驻留性：一旦作业被装入内存，会**一直驻留**在内存中，导致效率低

## 9.1 在传统非连续分配存储管理中实现虚拟内存计计数
请求调页（调段）和页面置换（段置换）的功能
1. 请求分页存储管理
2. 请求分段存储管理
3. 请求段页式存储管理

## 9.2 请求分页管理方式
### 9.2.1 页表机制
基本分页存储管理的页表是一维的，只记录内存块号。请求分页存储管理的页表增加了：**状态位**表示是否已调入内存；**访问字段**记录访问次数或者访问时间；**修改位**记录页面调入内存后是否被修改过；**外存地址**记录页面在外存的中存放位置。
### 9.2.2 缺页中断机构
访问的页面不在内存时，会产生**缺页中断**。此时缺页的进程阻塞，调页完成再唤醒。
如果内存中有空闲块，则为进程分配一个空闲块；如果没有，则由页面置换算法选择一个页面淘汰，如果没修改过不用写回。
缺页中断属于内中断，**属于故障**，可以被故障处理程序修复
### 9.2.3 地址变换机构
新增步骤：
1. 请求调页
2. 页面置换
3. 需要修改请求页表中新增的表项

## 9.3 页面置换算法
页面的换入、换出需要磁盘I/O，有较大开销，因此好的页面置换算法应该追求更少的缺页率。
### 9.3.1 最佳置换算法（OPT）
选择最长时间内不再被访问的页面，淘汰，把新页面换入。**无法实现**
### 9.3.2 先进先出置换算法（FIFO）
淘汰最早进入内存的页面 实现简单，但是会产生 **Belady 异常**--为进程分配的物理块数增大时，缺页次数不减反增。所以**算法性能差**

### 9.3.3 最近最少使用置换算法（LRU）
每次淘汰的页面时最近最少使用

### 9.3.4 时钟置换算法（CLOCK 或者 NRU 最近未用算法）
简单CLOCK算法：为页面设置访问位，把**内存中的页面**链接成一个**循环队列**（个人觉得用环形链表称呼更好）。**通过一个指针循环扫描**，发生置换时，检查访问位，如果是0直接换出，如果是1，则置为0，**暂不换出，继续检查下一个页面**（保证环形链表中每个页面只有一个），若全部页面都是1，进行第二轮扫描的时候肯定会有0的页面。**简单CLOCK算法选择淘汰一个页面最多经过两轮扫描**
改进型CLOCK算法：简单CLOCK 仅考虑是否被访问，但是没有修改的页面不需要执行I/O写回外存，改进CLOCK算法**最多进行四轮扫描**，除了有**访问位**，新增**修改位**，如（1，1）表示被访问且被修改，算法规则是：
1. 扫描到第一个（0，0）用于替换，不修改任何标志位。（最近没访问且没修改）
2. 若1失败，重新扫描一轮，查找第一个（0，1）替换，**把所有扫描过的页面访问位设为0**（最近没访问但修改）
3. 若2失败，重新扫描，查找第一个（0，0）替换，不修改任何标志位（最近访问但没修改）
4. 若3失败，重新改扫描，查找第一个（0，1）替换（最近访问且修改）

## 9.4 页面分配策略
**驻留集**：指请求分页存储管理中给进程分配的**物理块的集合**，一般小于进程总大小
固定分配：为每个进程分配一组固定数目的物理块，**驻留集大小不变**
可变分配：为每个进程分配一定数目的物理块，**驻留集大小可变**
局部置换：发生缺页时只能选进程自己的物理块置换
全局置换：把系统中空闲的物理块分配给缺页进程，也可以把别的进程持有的物理块置换到外存再分配给缺页进程

策略一：固定分配局部置换，很难确定分配多少个物理块
策略二：可变分配全局置换，只要缺页就会获得物理块，但是被调出物理块的进程缺页率会增加
策略三：可变分配局部置换可变分配全局置换，可根据缺页的频率来动态调整驻留集

### 9.4.1 何时调入页面
1. 预调页策略：同时调入多个相邻页面，在运行前调入
2. 请求调页策略：进程在运行期间发现缺页才调入，在运行时调入

### 9.4.2 何处调入页面
外存分为对换区和文件区，对换区读写速度更快，采用连续分配方式，文件区读写速度更慢，采用离散分配方式。
1. 系统有足够的对换区，在对换区调入调出
2. 系统缺少足够的对换区，在文件区直接调入，调出时写回磁盘对换区
3. UNIX方式，页面第一次使用，直接调入内存，换出时调入对换区。

### 9.4.3 抖动现象
频繁调入调出，主要原因是进程频繁访问的页面数目高于可用的物理块数。

### 9.4.4 工作集
指某段时间间隔内，进程实际访问页面的集合，一般来说，驻留集大小不能小于工作集大小，否则会频繁缺页。