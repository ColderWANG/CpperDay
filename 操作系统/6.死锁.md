- [1 死锁概念](#1-死锁概念)
  - [1.1 死锁发生的必要条件](#11-死锁发生的必要条件)
- [2 死锁的处理](#2-死锁的处理)
  - [2.1 预防死锁（静态策略）](#21-预防死锁静态策略)
  - [2.1.1 破坏互斥条件](#211-破坏互斥条件)
  - [2.1.2 破坏不剥夺条件](#212-破坏不剥夺条件)
  - [2.1.3 破坏请求和保持条件](#213-破坏请求和保持条件)
  - [2.1.4 破坏循环等待条件](#214-破坏循环等待条件)
  - [2.2 避免死锁 （动态策略）](#22-避免死锁-动态策略)
    - [2.2.1 银行家算法](#221-银行家算法)
    - [2.2.2 安全性算法](#222-安全性算法)
  - [2.3 死锁的处理](#23-死锁的处理)
    - [2.3.1 死锁的检测](#231-死锁的检测)
    - [2.3.2 死锁的解除](#232-死锁的解除)

# 1 死锁概念
死锁：各个进程互相等待对方的资源，导致各进程都阻塞，无法向前推进（有两个进程影响）
饥饿：由于长期得不到想要的资源，某进程无法推进（只有一个进程）
死循环：某个进程执行过程中跳不出某个循环，有时是程序逻辑bug，有时是程序故意设置的（是被管理者导致的）
## 1.1 死锁发生的必要条件
1. 互斥条件：抢夺同一个资源
2. 不剥夺条件：不能被其他进程强制夺走
3. 请求和保持条件：已经持有至少一个资源，又请求新的资源
4. 循环等待条件：存在进程资源的循环等待链

**结论**：对不可剥夺资源的不合理分配，可能导致死锁


# 2 死锁的处理
## 2.1 预防死锁（静态策略）
## 2.1.1 破坏互斥条件
把只能互斥使用的资源改造为允许共享使用（SPOOLing技术）
**缺点**：很多时候都无法破坏互斥条件

## 2.1.2 破坏不剥夺条件
方法1：某个进程请求新资源得不到满足，就立即释放所有资源
方法2：请求操作系统协助强行剥夺，一般要考虑各进程的优先级（比如：剥夺调度方式）
**缺点**：
1. 实现复杂
2. 释放已经获得的资源可能造成前一阶段工作的失效
3. 反复地申请和释放会增加系统开销
4. 若采用方案1，意味着只要暂时得不到某个资源，需要重新申请，如果一直发生，会导致饥饿

## 2.1.3 破坏请求和保持条件
采用**静态分配方法**，在进程运行前一次申请完所有需要的全部资源，并且**运行中一直霸占资源**
缺点：某资源利用时间短，还一直霸占，会导致**资源利用率低**，，也有可能**导致进程饥饿**

## 2.1.4 破坏循环等待条件
采用**顺序资源分配法**，对系统资源编号，规定每个进程**必须按编号递增的顺序请求资源**，同类资源（编号相同的资源）一次申请完。
缺点：增加新设备需要重新分配所有编号，不方便；使用资源的顺序可能和编号递增顺序不一致，导致资源浪费；用户编程麻烦

## 2.2 避免死锁 （动态策略）
### 2.2.1 银行家算法
**银行家算法**：在进程提出资源申请时，先预判此次分配是否会导致系统进入不安全状态，如果会进入不安全状态，就暂时不答应这次请求，让进程先阻塞等待。
流程：假设有 n 个进程，m 种资源

定义n*m的最大需求矩阵 Max、已分配矩阵 Allocation、最多还需要矩阵 Need

某进程申请资源 Request 为 m 维向量,剩余可用资源维 Available 为 m 维向量

1. Request <= need 则继续 ，否则说明申请超出最大需求，报错
2. Request <= avalible 则继续，否则说明尚无足够资源，等待
3. 修改相应数据
4. 执行安全性检测算法，分配后若处于安全状态，则正式分配，否则恢复数据，进程等待

### 2.2.2 安全性算法
检查当前的剩余可用资源是否满足某个进程的最大需求，如果可用，加入安全序列，并把该进程资源全部回收，**循环所有进程**，如果所有进程能加入安全序列，则说明安全，否则不安全

## 2.3 死锁的处理
### 2.3.1 死锁的检测
1. 用图结构保存资源的请求和分配信息，结点（进程和资源），边（在请求和已分配）
2. 一种算法检测系统是否进入死锁

死锁检测算法：
1. 在资源分配图中，找出既不阻塞又不是孤点的进程Pi，消边，成为孤立点。
2. 唤醒阻塞的进程，消边，依次进行，如果消除所有的边，则**可完全简化**

### 2.3.2 死锁的解除
死锁检测算法中不能消边的进程时**死锁进程**，死锁解除方法：
1. 资源剥夺法：挂起死锁进程，抢占资源
2. 撤销进程法（终止进程法）：强制撤销部分或全部死锁进程
3. 进程回退法：让进程回退到不发生死锁的时候