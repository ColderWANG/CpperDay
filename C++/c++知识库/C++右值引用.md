### C++右值和左值

在c++旧标准中，右值是不能被引用的，什么是右值呢？
> 左值的英文简写为“lvalue”，右值的英文简写为“rvalue”。很多人认为它们分别是"left value"、"right value" 的缩写，其实不然。lvalue 是“loactor value”的缩写，可意为存储在内存中、有明确存储地址（可寻址）的数据，而 rvalue 译为 "read value"，指的是那些可以提供数据值的数据（不一定可以寻址，例如存储于寄存器中的数据） 

通常我们可以用两种方法判断是否为右值
1. 可位于赋值号（=）左侧的表达式就是左值；反之，只能位于赋值号右侧的表达式就是右值
2. 有名称的、可以获取到存储地址的表达式即为左值；反之则是右值

### 右值引用的特点和作用(c++11)

右值引用的示例
```cpp
int &&r = 5; 
```
可以看出右值引用通过 && 来引用一个对象。右值引用(&&)和左值引用(&)具有**完全相反**的绑定特性。也就是说能被左值引用的对象不能被右值引用，反之亦然。
```cpp
int i = 42;
int &r = i;                   //正确
int &&rr = i;                 //错误，不能把右值引用绑定到左值上
int &r2 = i * 42;             //错误，i * 42 是一个右值
const int &r3 = i * 42;       //正确，可以用const 引用绑定右值
int &&rr2 = i * 42;           //正确
```
右值引用**只能绑定到临时对象**，具有两个性质
1. 所引用的对象将要被销毁
2. 该对象没有其他用户

意味着：
> 使用右值引用的代码可以自由接管所引用的对象的资源

但是由于**变量是左值**，所以我们不能用一个右值引用绑定右值引用类型！
```cpp
int &&rr1 = 42;
int &&rr2 = rr1;               //错误，变量表达式rr1是左值。
```
### 标准库 move 函数 左值引用与右值引用的区别
通过 std::move 函数，我们可以让一个左值对象作为右值来使用，但是这个左值对象会增加限制。
1. std::move 函数不提供 using 声明，必须通过 std::move 调用，而不是 move
2. 这个左值对象经过 move 后，可以销毁，也可以赋予新值，但不能使用其值

```cpp
int &&rr3 = std::move(rr1);   //正确，但是除了对 rr1赋值或销毁，我们不能再使用它。
```
区别：
> 左值引用只用于绑定左值，左值对象可以拥有多个引用，而常量左值引用既可以用于绑定左值，也可以用于绑定右值，而右值引用只能用于绑定右值，右值对象只有一个绑定，需要通过move函数来转移绑定权限。