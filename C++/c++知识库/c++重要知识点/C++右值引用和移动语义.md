### C++右值和左值

在c++旧标准中，右值是不能被引用的，什么是右值呢？
> 左值的英文简写为“lvalue”，右值的英文简写为“rvalue”。很多人认为它们分别是"left value"、"right value" 的缩写，其实不然。lvalue 是“loactor value”的缩写，可意为存储在内存中、有明确存储地址（可寻址）的数据，而 rvalue 译为 "read value"，指的是那些可以提供数据值的数据（不一定可以寻址，例如存储于寄存器中的数据） 

通常我们可以用两种方法判断是否为右值,**一般而言，左值表达式代表对象的身份，而右值表达式代表对象的值**
1. 可位于赋值号（=）左侧的表达式就是左值；反之，只能位于赋值号右侧的表达式就是右值
2. 有名称的、可以获取到存储地址的表达式即为左值；反之则是右值

区别：**左值持久，右值短暂**
### 右值引用的特点和作用(c++11)

右值引用的示例
```cpp
int &&r = 5; 
```
可以看出右值引用通过 && 来引用一个对象。右值引用(&&)和左值引用(&)具有**完全相反**的绑定特性。也就是说能被左值引用的对象不能被右值引用，反之亦然。
```cpp
int i = 42;
int &r = i;                   //正确
int &&rr = i;                 //错误，不能把右值引用绑定到左值上
int &r2 = i * 42;             //错误，i * 42 是一个右值
const int &r3 = i * 42;       //正确，可以用const 引用绑定右值
int &&rr2 = i * 42;           //正确
```
右值引用**只能绑定到临时对象**，具有两个性质
1. 所引用的对象将要被销毁
2. 该对象没有其他用户

意味着：
> 使用右值引用的代码可以自由接管所引用的对象的资源

但是由于**变量是左值**，所以我们不能用一个右值引用绑定右值引用类型！
```cpp
int &&rr1 = 42;
int &&rr2 = rr1;               //错误，变量表达式rr1是左值。
```
### 标准库 std::move std::forward 函数 左值引用与右值引用的区别
通过 std::move 和 std::forward 函数，我们可以让一个左值对象作为右值来使用，但是这个左值对象会增加限制。
1. std::move 函数不提供 using 声明，必须通过 std::move 调用，而不是 move
2. 这个左值对象经过 move 后，可以销毁，也可以赋予新值，但不能使用其值

```cpp
int &&rr3 = std::move(rr1);   //正确，但是除了对 rr1赋值或销毁，我们不能再使用它。
int &&rr4 = std::forward<int>(rr3) //std::forward 可以实现完美转发
//std::forward<T>(u) 有两个参数,T 为左值时，u 会被转换为 T 类型的左值，否则是T类型右值
```
区别：
> 左值引用只用于绑定左值，左值对象可以拥有多个引用，而常量左值引用既可以用于绑定左值，也可以用于绑定右值，而右值引用只能用于绑定右值，右值对象只有一个绑定，需要通过move函数来转移绑定权限。
### 移动语义 = 移动拷贝和移动赋值
对象接管资源，是提升性能的一种手段，也是为单例类转移资源的方式。
#### 移动构造函数和移动赋值函数
我们可以为类设计移动构造函数和移动赋值函数，其特性有
1. 移动构造函数接受的参数是该类类型的**右值引用**，和拷贝构造函数一样其他额外参数必须有默认实参。这个特性决定了转移后源对象必须是**销毁后无害**的。
2. 移动构造函数不分配任何新内存，所以移动语义操作不会抛出任何异常。当**编写不会抛出异常的移动操作时，应该事先通知标准库**。
3. 移后源对象必须可析构。
```cpp
class Type{
public:
    Type(Type&&) noexcept;              //移动构造函数，noexcept 表示告知不会抛出异常。
    Type &operator=(Type&&) noexcept;   //移动赋值函数
    Type(const Type&);                  //拷贝构造函数

    int val;
    int* val_;
}
Type::Type(Type &&s) noexcept: val(s.val),val_(s.val_) //接管资源
{  
    s.val_ = nullptr;                                  //确保源对象可析构，即可运行析构函数
}
Type &Type::operator=(Type &&s) noexcept{
    //排除自赋值
    if(this != &s){
        free();                                //释放已有元素，在里面处理：如果 val_ 有内存块，需要释放
        val = s.val;
        val_ = s.val_;
        s.val_ = nullptr;
    }
    return *this;
}


```
有了这些特性，我们可以知道，用 std::move 或者 std::forward 可以把一个左值（变量对象）用移动语义的方式被其他对象接管，避免拷贝的性能消耗。
需要注意的是，一个类定义了移动构造函数和拷贝构造函数，根据传入的参数类型匹配对应函数。**移动构造函数仅传入右值，拷贝构造函数不仅可以传入左值，还可以传入右值，因为const &类型可以绑定右值和左值**

```cpp
//测试
#include <iostream>
#include <vector>

using namespace std;

void foo(const int&)
{
  puts("foo(const int&)");
}

void foo(int&&)
{
  puts("foo(int&&)");
}

template <typename T>
void func(T&& s){
    foo(std::forward<T>(s));      //完美转发
    // foo(s);                    //全输出 "foo(const int&)"
    // foo(std::move(s));         //全输出 foo(int&&)
}
int main(){
    int i = 2;
    func(i);   //传入左值，调用 foo(const int&)
    func(2);   //传入右值，调用 foo(int&&)            
    return 0;
}

```