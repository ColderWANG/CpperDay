作者：Bettygirl
链接：https://www.nowcoder.com/discuss/990856?channel=-1&source_id=discuss_terminal_nctrack&trackId=undefined
来源：牛客网

面试官是校友，看到我的简历的毕业年份愣了一下，觉得不应该是个非应届的过来

自我介绍
继续做字节的舔狗

八股/项目（50min）
问简历的内容，其实还行。主要环节是，智能指针拷打（这块好像说了20min左右），一致性哈希拷打，RPC拷打。

1. 用过C++11吗？
用过
2. 知道 unique_ptr 吗？
知道，是独占所有权的智能指针
3. 怎么实现独占所有权？怎么转移所有权？
我去 cplusplus 网址看过接口，unique_ptr 禁用**拷贝构造函数**和**赋值操作符**，通过**移动构造函数和移动赋值操作符**来转移所有权
4. b = a; 怎么实现？b = move(a); 怎么实现？
b = a 被禁用了，b = move(a) 重载了移动赋值操作符
```cpp
    Unique_ptr &operator=(Unique_ptr &&rhx) noexcept
    {   
        if(rhx.get() != this.ptr)[  //排除自赋值
            this->reset(rhx.release());
        ]
        return *this;
    }
```
5. 知道 shared_ptr 吗？
知道，是共享所有权的智能指针
怎么实现的共享所有权？
引用计数
引用计数和管理的内存地址怎么实现的？是同一块内存空间吗？
都在堆区
make_shared 会放在同一个空间
在定义 shared_ptr 的时候，如果 shared_ptr<T> p(q) 中 q 不是动态空间的指针，需要自定义删除器，但是尽量用 make_shared 而不是 new，因为 make 函数减少了代码重复，提高了异常安全。
6. 引用计数和管理的内存是相生相依的吗？
没搞懂，最后就问了这两个是同时创建的吗？
其实不是，传入 new xxx 的构造函数就不是
7. 同样问了 shared_ptr 的 b = a; 怎么实现？b = move(a); 怎么实现？
赋值运算符写法：1.排除自赋值 2.= 左边的智能指针引用计数-1，如果为0就删除，= 右边的变量的引用计数+1. 移动赋值一样。
8. （想问点分布式存储相关的）知道raft吗？
只了解是个分布式共识算法，没了解具体内容（论文都没看，我可不敢说我了解了）
看我没有相关经历，那就挖一挖简历吧
9. 知道一致性哈希吗？
一致性哈希也是使用取模的算法，但是普通hash算法是对服务器数量取模，而一致性hash算法是对2^32取模。具体步骤如下：
一致性哈希算法把哈希值空间按照顺时针方向组织成一个虚拟圆环，称为 hash 环。
接着将各个服务器使用 hash 函数进行哈希，具体可用选择服务器的 ip 或主机名作为关键字进行哈希，从而确定每台机器在 hash 环上的位置
最后使用算法定位数据访问到相应服务器，将数据 key 使用相同的函数 hash 计算出 hash 值，并确定此数据在环上的位置，从此位置沿环顺时针寻找，第一台遇到的服务器就是其应该定位到的服务器。
**优点**：对于节点的增减，只需要重定位环空间的一小部分数据，只有小部分缓存失效，不至于把大量压力集中到后端服务器上，有较好的容错性和可扩展性。
**hash 环的倾斜**在极端情况下，有可能引起系统的崩溃，为了解决这种数据倾斜问题，一致性哈希算法引入了**虚拟节点机制**，对每一个服务节点计算多个哈希，每个实际物理节点对应多个虚拟节点，hash 环上的节点越多，缓存均匀分布的概率就越大，hash 环倾斜的影响就越小。
10.   互斥锁，信号量使用的场景区别
一个线程互斥，另一个线程同步
11.  互斥锁，读写锁，自旋锁的区别
基本锁包含二类：**互斥锁**和**自旋锁**
自旋锁：线程反复检查锁变量是否可用，由于线程在这一过程中保持执行，是一种**忙等**，避免了进程上下文的调度开销，因此对于线程只会阻塞很短时间的场合是有效的
互斥锁：用于并发编程中，防止两条线程对同一公开资源进行读写的机制，把代码划分成一个个临界区，线程访问临界资源时会检查是否被其他线程使用，如果被其他线程使用，此线程会进入睡眠，等待锁释放则被唤醒，是一种**闲等**
读写锁：是一种特殊的互斥锁，把共享资源划分成读者和写者，读者只对共享资源进行读操作，写者需要对共享资源进行写操作，这种锁对于自旋锁而言可用提高并发性，一个读写锁同时只能有一个写者或多个读者，但不能同时有读者和写者。适用于对共享资源读的次数比写次数多得多的情况
12. 怎么实现自旋锁
**TAS**（test and set） 算法实现:
```cpp
#include <atomic>
// 采用 std::atomic_flag 实现自旋锁互斥，即 TAS 算法（Test And Set）
class AMySpinLock1
{
public:
    AMySpinLock1() = default;
    AMySpinLock1(const AMySpinLock1&) = delete;
    AMySpinLock1& operator=(const AMySpinLock1&) = delete;
    void lock()
    {
        while(flag.test_and_set(std::memory_order_acquire));
    }
    void unlock()
    {
        flag.clear(std::memory_order_release);
    }
 
private:
    // std::atomic_flag 类型的对象必须由宏 ATOMIC_FLAG_INIT 初始化，它把标志初始化为置零状态。
    std::atomic_flag flag = ATOMIC_FLAG_INIT;
}
```
**CAS** (compare and swap) 算法实现：
```cpp

class AMySpinLock2
{
public:
    AMySpinLock2() = default;
    AMySpinLock2(const AMySpinLock2&) = delete;
    AMySpinLock2& operator=(const AMySpinLock2&) = delete;
    void lock()
    {
        // 判断 flag 对象封装的 bool 值是否为期望值(false)：
        // ① 若 bool 值为 false，与期望值相等，说明自旋锁空闲。此时，flag 对象写入 true，返回 true，即上锁成功。
        // ② 若 bool 值为 true，与期望值不相等，说明自旋锁被锁。此时，while 将一直循环，直到返回 true 为止。
        bool expected = false;
        while(false == flag.compare_exchange_strong(expected, true))
        {
            // 当 compare_exchange_strong 返回 false 时，
            // 证明 expected 与 flag 不相等，此时 expected 为false，flag 为 true；
            // 则将 expected 赋值为 flag 的值，即此时 expected 为 true 了，
            // 因此要修改为 false 后，才能进入下一次循环。
            expected = false;
        }
    }
    void unlock()
    {
        flag.store(false);
    }
 
private:
    // flag 对象所封装的 bool 值为 false 时，说明自旋锁未被线程占有。
    std::atomic<bool> flag{false};
}
```

13. RPC的实现流程？
RPC 是远程过程调用。服务端注册方法或类，客户端封装封装对外的API，让用户像调用本地接口一样调用远程接口。首先客户端和服务端需要建立通信连接（TCP连接），客户端需要序列化方法和参数等信息，服务端需要对收到的数据反序列化，得到数据，根据请求数据查找对应的实现类或方法，在序列化传输回去，客户端反序列化数据得到结果。

怎么在同一个端口，发布多个服务？
就说说自己咋实现的
怎么实现的超时？
socket设置，recv超时
然后开始问重试机制，如果需要我实现应该怎么实现？
最大重试次数，计数
如果同时发出很多个RPC请求，这个qps上不去，咋办？
不知道，想了一会说，也不能总是创建很多个线程吧
然后就说可能得用I/O多路复用了
RPC调用的同步和异步，和之前说的同步和异步，是一个意思吗？
socket的同步阻塞，是收到数据前，一直阻塞，等着
这个是在得到调用结果前，是否可以继续做下面的事情
那我继续问，如果同一个RPC调用，按照你之前的重试机制实现，如果前一个请求（涉及到写，非幂等，比如文件创建）是成功的（但是做的太久，设置的超时太短，以为超时失败了），后面重试的请求失败了（显示文件已创建），应该怎么解决？
想了很久，说同一个请求的数据包都是通过请求id关联的，
那么每个请求，都单独开个线程去等（因为重试的次数本就不多），然后请求到的结果，放入哈希表，当然，也放到队列里面
通过请求id，索引哈希表，看看有没有最近的成功请求结果，如果有，之后的失败请求，就没必要记录了
那么，根据这个实现，如果第一次的请求是响应成功的，但是由于网络原因失败，应该怎么办？
不懂了，之后没继续深挖
那么就说webserver吧（简历的项目名称不是webserver，不过被一眼看出，老面试官了）。你知道I/O多路复用机制，除了epoll，还有啥吗？
select，poll，原理差不多，没让说具体原理
ET和LT的区别？
八股文
ET和LT哪个性能更好？
一般认为ET更好，毕竟可以从内核中少拷贝就绪文件描述符
但是，ET伴随着使用非阻塞socket，要一次性读完、写完数据，也就是说可能进行的 read 或者 write 系统调用会更多
至于是否真的更好，目前没有定论，需要在更多的环境、场景下去测试
算法题（10min）
直接就在飞书上了，ACM模式

排序链表（LeetCode 148）

让选择一种比较擅长的实现，选择了最简单的递归版归并排序，不过今天当天写过，所以bug free了
然后讨论了 new 了新节点，没释放的问题（这个习惯在工程实现上确实不好），修改了下代码
反问
目前在做的工作，编程语言，技术栈
文件系统，C++
平时会用什么库，或者什么其他技术栈
有一些自研的，也有RPC（字节自己的RPC，百度brpc），也用类似muduo的这种网络库
涉及到数据库（存储引擎）吗
没有，这个是数据库的组做的
我的表现有什么需要改进的？什么时候能知道结果？
还行，挺好的
几天之内，可以问hr
总结
总体而言，聊的很愉快，虽然中间确实有部分问题不会回答，也回答不够好

项目中的一致性哈希，这块背的不太熟，下次还得再练练

其他还好

二面（50min）
面试官比较年轻，也还好，不会给人很严肃的感觉，没回答上的问题，也没有关系

自我介绍
继续舔狗，说到「字节跳动是我非常尊敬和仰慕的公司」，当然其实每次面试都会说这句话

面试官笑了（尴尬）

八股/项目（25min）
用的是C++11吗？（固定开场了这是？）
用过
1. C++11新特性有啥？
nullptr 类型推导（auto decltype）范围for 初始化列表 using可以为模板定义名称
默认模板参数 委托构造函数 using继承构造 新增容器array forward list 无序容器unordered_map等 元组tuple 正则表达式 线程库 lambda表达式 std::function 右值引用和移动语义

2. 解释什么是左值，什么是右值，move 是干啥的（超高频了）
左值是可寻址表达式，在等号左边的，一般是变量。右值是只读表达式，在等号右边的，一般是临时值
move 的作用是把传入的值转化为右值，用于实现移动语义。

3. 什么时候用到右值，移动构造函数/移动赋值运算符函数的流程
右值一般用来实现移动语义，移动语义就是让对象接管所有权，是一种高效的转移资源的手段。移动构造函数的参数是右值引用，用自己的成员变量接受后，如果是指针的话需要把右值引用赋为空。移动赋值运算符多了两个步骤，需要排除自赋值，并且需要释放自己的成员变量占有的内存

4. 虚拟内存和物理内存的差别，为什么要用虚拟内存？
**作用**不同：虚拟内存使程序认为拥有连续的可用内存；物理内存使在计算机运行时位操作系统和程序提供临时存储。
**特点**不同：虚拟内存是一种内存管理技术，被分隔成多个物理内存碎片，还有部分暂时存储在外部磁盘，在需要时进行交换；物理内存是操作系统和应用程序运行的硬件实体。
为什么使用虚拟内存：
4.1 可以使得进程的运行内存超过物理内存大小，根据局部性原理可以对没有被经常使用的内存换到硬盘交换区
4.2 由于每个进程都有自己的页表，所以每个进程的虚拟内存空间就是相互独立的。解决多进程之间地址冲突的问题
4.3 页表里页表项中除了物理地址外，还有一些属性标记，在内存访问方面提供更好的安全性
5. 虚拟内存有哪些部分？
内核区、用户区
用户区有代码段、数据段、堆栈段（中间还有个文件映射区）
6. 虚拟内存的查询流程
内存分段查询：**虚拟地址由段选择因子和段内偏移量，操作系统维护一张段表，通过段号在段表查找段基地址、段大小等信息，段内偏移合法的话，加上端基地址就得到物理内存地址**。
内存分页查询：分页把整个虚拟和物理内存空间切成一段段固定尺寸的大小，Linux下的一页是4KB。进程查找页表找不到时，会产生缺页中断。**虚拟地址分为物理页号和页内偏移，通过页号在页表查找基地址，判断页内偏移是否合法，加上基地址就是物理内存地址**。（一个进程的虚拟内存为4GB，则页表本身为4MB）**一个页表项为4字节，和系统位数一样避免产生碎片**
多级页表查询：如果进程容量太大，页表的页表项太多，很多进程在运行的时候，光是页表就占用了很多内存。**虚拟地址分为一级页号、二级页号、页内偏移，一级页表的页表项放二级页表地址，二级页表的页表项放物理页号，维护一级页表额外占用4KB，维护二级页表占用4MB，从PCB中读取一级页表始址，根据一级页号查找二级页表地址，根据二级页号查找物理页始址，结合页内偏移得到物理地址**

7. C++ 的 new 运算符流程
operator new
调用构造函数
8. malloc 函数返回的地址是什么地址
虚拟地址
malloc 返回什么样的地址，如果分配10字节。
malloc小于128k的内存，使用brk分配内存，将_edata往高地址推(只分配虚拟空间，不对应物理内存(因此没有初始化)，第一次读/写数据时，引起内核缺页中断，内核才分配对应的物理内存，然后虚拟地址空间建立映射关系)
malloc大于128k的内存，使用mmap分配内存，在堆和栈之间找一块空闲内存分配(对应独立内存，而且初始化为0)
实际上不是每次都调用，空闲内存会链接成 Block 链表，没有适合的Block则会向内存池申请
9. 面试官追问，如果链表太长咋办？
可以和分配器的二级分配器一样，每次分配一大块内存（内存池），并维护对应的自由链表，比如16个自由链表，第一个为 8，后面依次增加 8.如果有可用的自由链表则利用，否则通过chunk_alloc()从内存池申请空间，缺省申请20个block。
10. 这个链表的并发访问，除了加锁还有啥方法吗
说了下原子操作（也不知道对不对）
11. 了解thread local吗？（听过名字，没了解具体原理，寄）
【动态链接库】和【静态链接库】的区别？
我本来想先说【动态链接】和【静态链接】的区别的，我就试图先说这个，想杀点时间
但是，又问静态库 .a 和动态库 .so 有啥不同。麻了，没回答上，回去好好看
然后又追问，怎么查看使用到的动态链接库？麻了，忘了，滚去复习（寄）
C++一般用啥编译工具？
make、cmake
有什么工具，能查看编译后可执行文件的函数？
objdump
其他想不到了，失忆了（寄）
你用到了protobuf，知道protobuf是怎么存的吗？（指的是底层怎么进行的序列化）
不知道，只知道序列化后是二进制的
用protobuf的好处
八股文
看过什么开源库（关于存储的）
我可不敢说leveldb，省的被怼死
就说没看过
了解mysql吗？（面试官很无奈，其他啥也不知道，mysql总知道吧）
了解
mysql存储引擎，用的什么数据结构？
B+树
B+树怎么查询的？
八股文
失算了，本来想等着面试官问点更深的东西，看来我应该主动说点mysql（innodb/myisam）对B+树的具体实现
为什么用B+树，不用B树？
八股文
算法题（25min）
飞书，ACM模式

重排链表（需要最优解，LeetCode 143）

明明很简单，但是写的有点磕绊，面试官说中途接个电话，暂时消除了紧张感，然后快速把代码框架敲出来
中间写了个bug，在debug，结果发现前面没问题，就是后面合并出了问题
有惊无险，写出来了
反问
如果有幸通过面试，需要提前了解什么？
不需要，可以看看存储相关的开源库，对实习生要求不高
面试过程中更看重候选人哪些能力？（接着来问的，既然说对实习生要求不高嘛）
基础、跟存储相关经历
怎么培养实习生，会让刚来的实习生干啥？
（内容略）
最后说，如果没有基础，进来之后会有点痛苦
感觉面试官略微有点劝退，可能是在暗示我过不了？
我的表现有什么需要改进的地方？
表现还可以，对存储不够了解，得讨论一下是否能通过，之后可以问hr结果（加粗的地方也是最终面评内容，hr说不便透露具体内容）
我这块有点失误了，应该得更虚心点，解释投这个岗的原因（因为面试官觉得投这个岗，要对存储有所了解），但是我就说了个确实（好糟糕的回答），不过可能再咋说也改变不了啥结果
总之就是，通过的概率不如上次高，怕是要收到感谢信了
总结
总体而言这次表现的不算理想，问到了一些知识盲区，也在表达技巧上出了点小失误

虽然确实没有存储相关的经历，但是总体来说，面试体验还不错，面试难度较为友好，面试过程中，不会因为我没有这方面的经历而刻意刁难我

今年总体而言，比去年的表现好点，没有出现口吃的情况，表达也较流畅，算法题顺利解出。内推我的同学也觉得我的表现大概率能过二面，但是他也没想到，hc确实没了，觉得很离谱，面评给了个「没有存储经历」的理由拒绝（对校招生这样要求也情有可原，对日常实习生也是这个要求，就离谱了，应该被冲kpi了），因为去年他面这个岗的时候，也是跟我差不多，没有相关经历的。可能这会在hc收缩的情况下，想面进来的难度，至少得是校招sp一档的吧，那就必须要有相关经历，并且可能掌握的比较深，才行。

对不起，也让去年给我支持的朋友们失望了。我也很对不起我自己。

哎，我真的尽力了，我已经掌握的各种各样的技巧也用上了。只能说，虽然我不少同学都进来了，我也心心念念一年多，还是跟去年一样的结果，二面仍然是我不可逾越的门槛。虽然我的实力确实尚且也达不到校招要求，可能确实跟这家公司也没啥缘分吧。之后有机会了就再接再厉吧，我真的累了。

哦对，顺便说一下，我集齐了字节感谢信的两套模板。